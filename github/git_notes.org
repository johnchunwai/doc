git config --global user.name "YOUR NAME"
git config --global user.email "name@users.noreply.github.com"
git config --global credential.helper wincred

https://git-scm.com/blog

per repo:
cd to your repo
git config user.email "name@users.noreply.github.com"

git clone https://gitrepo-url

create proj
-----------
nav to dir with proj files
git init

search for changes
------------------
git log -p -- 'filename' --since='1 week ago'
git log -p --grep='some words in commit comment'

find text from committed files from all branches
------------------------------------------------
git grep 'regex' $(git rev-list --all)


stage file (add files for commit or include the updated file in the commit)
----------------------------------------------------------------
git add filename
git commit -m "some comments"

git add --patch
#cherry pick things to stage

git reset --patch
#cherry pick what to reset

git checkout --patch

revert staged changes
----------------------
git reset HEAD filename
#unstage
git checkout filename
# revert unstaged changes
# commit after this point may be lost if no branch/tag is created (can be created later), the change is referred to by hash
OR
git checkout -f filename

git checkout '@{1 week ago}' filename
# grab a file a week ago and stage it

revert commit with history
--------------------------
git revert HEAD/<hash>
OR
git reset --hard HEAD~
git reset --soft <latest ref=original HEAD>
git commit

revert commit without history
-----------------------------
git reset --hard <tag>/<hash>
# --hard updates working directory if the changes are tagged, they'll still be shown in log --all

amend last commit
-----------------
git add file
git commit --amend -m 'new comment'
OR
git reset <prev hash>
git add file
git commit -m 'new comment'
OR
git reset --soft <prev hash>
git commit -m 'new comment'

git diff
git diff --cached
#between staged and head


move file
---------
git mv <file> <dir>
git commit
OR
mv <file> <dir>
git add <dir/file>
git rm <file>
git commit

create branch
-------------
git checkout -b <branchname>
OR
git branch <branchname>
git checkout <branchname>

git branch -D branchname
#del branch


view branches
-------------
git branch -v

merge changes from branch to master
-----------------------------------
git checkout master
git merge --squash <branchname>
# squash all commits into a single one from branch
git commit

rebase instead of merge
-----------------------
git checkout master
git rebase master

commit all modified files
-------------------------
git commit -a -m 'comment'
OR
git add -A
git commit -m 'comment'

uncommit last change and get back to previous staged files
----------------------------------------------------------
git reset --soft HEAD~

move uncommitted changes to another branch
------------------------------------------
git stash
git checkout <branch>
git stash pop/apply
#pop removes the stash while apply won't


git status


git tag <tagname>
git tag
# show tags
git tag -d 'tagname'
#untag

git log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short master --all

git rebase -i HEAD~[N]
#interactive rebase

remote
======
#clone
git clone https://github.com/blah

#create
git remote add origin https://github.com:username/repo-name
or
git remote add origin git@github.com:username/repo-name.git

#show both local and remote braches
git branch -av

#list
nav to proj folder
git remote -v

git push origin <localbranch>:<remotebranch>
#shortcut if both local and remote branches are named master
git push origin master
#shortcut if all branch on local and remote are the same
git push

#push local to remote with tracking
git push -u origin <localbranch>

#delete branch from local and remote
git branch -D <branch>
git push origin :<branch>

#get changes from remote
git fetch origin
git 

* detach subdiretory into separate repo
** prepare old repo
#+BEGIN_SRC 
pushd <big-repo>
git subtree split -P <name-of-folder> -b <name-of-new-branch>
popd
#+END_SRC
** create new repo
#+BEGIN_SRC 
mkdir <new-repo>
pushd <new-repo>
git init
git pull </path/to/big-repo> <name-of-new-branch>
#+END_SRC
** link new repo to github
#+BEGIN_SRC 
git remote add origin <git@github.com:my-user/new-repo.git>
git push origin -u master
#+END_SRC
** clean up old repo
#+BEGIN_SRC 
popd # get out of <new-repo>
pushd <big-repo>
git rm -rf <name-of-folder>
#+END_SRC
