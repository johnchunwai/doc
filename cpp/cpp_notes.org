* Initialization
{} init avoid implicit conversion compared to = initialization.
Exception for auto.
#+BEGIN_SRC 
int i = 7.8;	// i becomes 7
int i {7.8};	// error: floating-point to integer conversion
auto i = 7.8;	// no implicit conversion as auto retains the type as double
auto i {7.8};	// more consistent syntax

#+END_SRC

* Deducing types

** template type deduction
#+BEGIN_SRC 
template<typename T>
void f(ParamType param);
// eg for ParamType: T, const T&, T&& etc

f(expr);	// deduce T and ParamType from expr

#+END_SRC
1) ParamType is ptr/ref, NOT universal ref
   - expr is ref, ignore the ref part
   - match expr's type against ParamType to determine T
#+BEGIN_SRC 
template<typename T>
void f(T& param);

int x = 27;
const int cx = x;
const int& rx = x;

f(x);	// T int, param int&
f(cx);	// T const int, param const int&
f(rx);	// same as above

template<typename T>
void f(T* param);

int x = 27;
const int *px = &x;

f(x);	// T int, param int*
f(px);	// T const int, param const T*

#+END_SRC
2) ParamType is universal ref
3) ParamType is NOT ptr/ref


* Constants
constexpr - evaluated at compile time
constexpr functions
- can accept non-const args but the result is not a constexpr (so we don't need to duplicate a function for both constexpr and non constexpr use)
- cannot have side effects (no changes to non-local variables

* Misc
- variable can be defined in if statements and has scope for both if and else block
#+BEGIN_SRC 
if (auto x = v.size(); x != 0) {
	// works like for
}

if (auto x = v.size()) {
	// similar to above but implicit check for x != 0. Basically similar to if (x)
}

#+END_SRC
