* Fundamentals
** ascii
- 0-127 same everywhere
- 128-255 depends on code page (eg. Israel=862, Greek=737)
  - worse on Asia, DBSC (double byte character set), some 1 byte, some 2

** unicode
- each character has a unique `code point' != binary rep (eg. A = U+0639)

*** BOM (byte order mark)
- pointless for utf-8
- specifies endianess
- eg. for utf-16 (or ucs-2)
-- FE FF -> big endian (small memory location == most significant byte)-> (eg. 0x0048 -> 00 48)
-- FF FE -> small endian (small memory location == least significant byte)-> (eg. 0x0048 -> 48 00)

*** utf-8
| bits | min_code_point | max_code_point | bytes |   byte_1 |   byte_2 |   byte_3 |   byte_4 |   byte_5 |   byte_6 |
|------+----------------+----------------+-------+----------+----------+----------+----------+----------+----------|
|    7 | U+0000         | U+007F         |     1 | 0xxxxxxx |          |          |          |          |          |
|   11 | U+0080         | U+07FF         |     2 | 110xxxxx | 10xxxxxx |          |          |          |          |
|   16 | U+0800         | U+FFFF         |     3 | 1110xxxx | 110xxxxx | 10xxxxxx |          |          |          |
|   21 | U+10000        | U+1FFFFF       |     4 | 11110xxx | 1110xxxx | 110xxxxx | 10xxxxxx |          |          |
|   26 | U+200000       | U+3FFFFFF      |     5 | 111110xx | 11110xxx | 1110xxxx | 110xxxxx | 10xxxxxx |          |
|   31 | U+4000000      | U+7FFFFFFF     |     6 | 1111110x | 111110xx | 11110xxx | 1110xxxx | 110xxxxx | 10xxxxxx |

- 0 as null terminating character still works with utf-8 string

** encoding

For email or web:
#+BEGIN_EXAMPLE
Content-Type: text/plain; charset="UTF-8"
#+END_EXAMPLE

For web alternatively (meta must be the first thing in <head>):
#+BEGIN_EXAMPLE
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
#+END_EXAMPLE

